
- 백버퍼에 Ractangle로 사각형을 그리고, 그 백버퍼에 다시 BitCopy로 로드한 이미지 HDC 정보를 삽입하면 화면이 깜빡거린다.
  이렇게 화면이 깜빡거리는 이유는 너무 많이 갱신되서 그런 것이다. 마치 그려지는 이미지들끼리 다투는 현상.

  이를 방지하기 위해서, 백버퍼와는 별개로 윈도우(창) 크기만한 빈버퍼(공백 이마지)를 하나 만들어서 활용한다.
  그곳에 이미지를 그린 후, 해당 공백 이미지를 백버퍼에 BitCopy 한다.

  백버퍼는 GameEngineImage 클래스가 HDC로 핸들링하고 있는 상황이지만(윈도우(창)과 연결된 상황), 빈버퍼는 연결되어 있지 않다.
  이 연결되지 않은 HDC를 백버퍼에 덮어씌우기 하는 것이다.


- 0120 수업때 아래와 같이 맵 만듬
  GameEngineRender* Render = CreateRender("Move0_Map.Bmp", RenderOrder::Map);
  Render->SetPosition(GameEngineWindow::GetScreenSize().half());
  Render->SetScaleToImage;
 
  그렇다면 해당 이미지의 맵타일은 어떻게 하는가?
  본래라면 기본적으로 모두 윈도우의 half에 정렬될 것이다.
  이때, 맵 이미지를 half가 아닌 0,0을 기준으로 그려지도록 한다.
  이러면 타일맵도 0,0 부터 그려지기 때문에 1:1 크기로 매칭된다.
  >> 해당 부분이 헷갈리면 이미지맵 왼쪽 상단에 무언가 색칠해놓은 뒤, 랜더링해서 확인해보도록 한다.
  
  가장 쉬운 충돌방식은 자신의 Position이 이미지의 Position이 되는 것이다.
  내가 만약 1000x1000에 위치한다면, 이미지의 위치도 1000x1000이 되도록 하는 것이다.
  이게 겹쳐지는 상황에서 GetPixel로 충돌을 발생시키는 것이다.
  
  그렇다면 이미지는 어떻게 정렬해야 할 것인가?
     Render->SetPosition(GameEngineWindow::GetScreenSize().half());    << 이걸 바꿔서
     Render->SetPosition(Render->GetImage()->GetImageScale().half());  << 이게 되야한다.
  
  왜냐하면, half 설정 시 정 중앙에 이미지가 위치할 것이지만, 이미지의 절반 오른쪽, 절반 아래쪽으로 이동시키면 0, 0이 되기 때문이다.
  플레이어 캐릭터는 해당 이미지가 그려진 부분에서 시작할 수 있도록 위치를 정해주면 된다(플레이어 시작점 설정).
  >> 이미지를 이동시키는 것이 아니라, 캐릭터와 카메라의 위치를 이동시키는 개념이다.
  
  이렇게 해도 생각처럼 되지 않을 수 있지만, 이동시켜야 한다는 개념은 알고있어야한다.